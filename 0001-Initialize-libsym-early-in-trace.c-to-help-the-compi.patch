From b882ba7bd0840db234eb84c27665da4b3f4b42b8 Mon Sep 17 00:00:00 2001
From: Mark Wielaard <mjw@redhat.com>
Date: Thu, 9 Jan 2014 22:56:35 +0100
Subject: [PATCH] Initialize libsym early in trace.c to help the compiler.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

GCC 4.4.7 isn't smart enough to realize own_libsym will always be zero
when it sees the goto done which might jump over the initialization of
libsym. And so will produce a warning like:

cc1: warnings being treated as errors
trace.c: In function ‘ifunc_ret_hit’:
trace.c:1433: error: ‘libsym’ may be used uninitialized in this function
---
 sysdeps/linux-gnu/trace.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/sysdeps/linux-gnu/trace.c b/sysdeps/linux-gnu/trace.c
index e648b8f..0abb545 100644
--- a/sysdeps/linux-gnu/trace.c
+++ b/sysdeps/linux-gnu/trace.c
@@ -1390,6 +1390,7 @@ ifunc_ret_hit(struct breakpoint *bp, struct process *proc)
 
 	struct breakpoint *nbp = NULL;
 	int own_libsym = 0;
+	struct library_symbol *libsym = NULL;
 
 	struct value value;
 	value_init(&value, proc, NULL, type_get_voidptr(), 0);
@@ -1430,8 +1431,7 @@ ifunc_ret_hit(struct breakpoint *bp, struct process *proc)
 
 	/* Look if we already have a symbol with this address.
 	 * Otherwise create a new one.  */
-	struct library_symbol *libsym
-		= library_each_symbol(lib, NULL, libsym_at_address, &u.a);
+	libsym = library_each_symbol(lib, NULL, libsym_at_address, &u.a);
 	if (libsym == NULL) {
 		libsym = malloc(sizeof *libsym);
 		char *name = strdup(bp->os.ret_libsym->name);
-- 
1.7.6.5

